
## 1. GDB如何调试core文件？
core文件定义：\
&emsp;&emsp;在程序崩溃时由操作系统生成的文件(也叫核心转储文件)，通常包含了程序崩溃时的**内存快照**、**堆栈信息**和其他调试信息。\
使用gdb调试core文件的作用：\
&emsp;&emsp;可以查看程序崩溃时的状态，包括程序变量、调用栈等\
操作步骤：\
&emsp;生成core文件、使用gdb调试core文件、其他调试细节/命令
### 1.1 生成core文件
在调试core文件前，需要让操作系统生成core文件，因为在Linux系统中生成core文件的大小是收到限制的，使用`ulimit`命令可以查看和修改这个限制：
```bash
ulimit -c unlimited
```
这个命令取消了core文件的大小限制。无限的core文件可能会消耗大量磁盘空间，因此在生产环境中使用时需要谨慎，可以在开发和测试的环境中使用以方便调试。
>如果希望<font color=blue>永久性地设置core文件大小限制，需要编辑系统的配置文件</font>，可以修改/etc/security/limits.conf文件或者修改/etc/profile或者/etc/bashrc文件

默认情况下，生成的core文件通常是保存在程序的当前工作目录中，文件名为core。可以通过修改/pro/sys/kernel/core_pattern文件修改保存在特定目录中并设置不同的文件名格式。

### 1.2 使用gdb调试core文件
调试命令格式：
```bash
gdb <可执行文件> <core文件>
```
可执行文件是编译后的二进制文件，所以需要编译成功之后才能进行调试。
core文件则是相对应核心转储文件。
例如：
```bash
gdb my_program core.12345

```
当执行上述命令的时候，GDB会加载可执行文件和core文件，尝试重建崩溃时的程序状态。如果程序崩溃时包含了符号信息(通过调试符号编译)，会得到更详细的信息。

### 1.3 其他调试细节/命令
- 在使用gdb对程序进行调试的时候，调试符号的定位非常重要。调试符号包括(如函数名、变量名、行号等)，没有调试符号的core文件会显示不完整的信息，通常只有机器码级别的堆栈追踪。
为了确保生成的core文件包含调试信息，编译时需要使用-g的参数选项来生成调试符号。例如：
```bash
g++ -g -o program program.cpp
```
gdb常用命令速查：\
`print`: 打印变量的值\
`break`: 设置断点，后面可以是行号、函数名等信息\
`list`: 查看崩溃位置附近的源码。\
`info locals`：查看当前函数所有局部变量的值。\
`infor registers`: 查看CPU寄存器的内容，特别有用来诊断程序崩溃时的状态。\
`frame`: 查看当前栈帧的详细信息，可以使用frame命令切换不同的堆栈帧\
关于多线程调试相关命令：
>`info threads`: 查看所有线程，输出类似于：
```Id   Target Id         Frame
1    Thread 0x7ffff7fa3 (LWP 12345) main ()
2    Thread 0x7ffff7f1c (LWP 12346) worker_thread ()
```
`thread <thread_id>`: 切换到指定线程\
`thread`: 查看当前线程信息



## 2. C++中的智能指针有哪些？weak_ptr的实现原理是什么？
智能指针有shared_ptr、unique_ptr、weak_ptr


## 3. STL中的map中的数据是有序的吗？unordered_map中的数据呢？为什么不直接使用unordered_map去替换掉map呢？
map与unordered_map是C++中实现的对k-v对实现的数据结构。它们的本质区别在于低层实现的数据结构不一样。unordered_map底层实现为哈希表，而map底层实现是红黑树。所以在查询的效率上，unordered_map通常是比较高的，时间复杂度为O(1)的级别，而map则是O(logn)。




## 4. 如何理解C++中的 atomic？
摘自：https://mp.weixin.qq.com/s/sgoEnIMdXEocdcwC7doBmA
先说总结：
* std::atomic是C++标准库中用于处理**多线程环境下原子操作**的强大工具，它是硬件级别的。它通过**硬件支持和编译器**优化，确保了对共享数据的访问是不可分割的，从而避免了数据竞争问题。




## 5. std::move与std::forward的区别
https://mp.weixin.qq.com/s/ce4KR28EGwsEa6jVXqE7AQ






## 6. unique_lock和lock_guard的区别







## 7. C++中的explicit关键字的含义是什么？有什么作用？
关键字explicit用于标记构造函数或转换运算符，以禁止编译器在需要时进行隐式类型转换。主要有以下几个方面的含义：
1. 防止隐式转换
默认情况下，如果一个类有单参数构造函数（或可用默认参数使其看起来像单参数构造函数），编译器可能会将这种构造函数用于隐式类型转换。使用 explicit 可以阻止这种自动转换，从而避免意外的错误或歧义。

2. 应用于转换运算符（C++11 之后）
从 C++11 开始，explicit 也可以用于转换运算符，以防止隐式转换。
通过显式转换运算符，编译器不会在不经意间将对象转换为 bool，从而避免在逻辑判断中出现隐式转换错误。

3. 设计上的考虑
代码可读性：使用 explicit 强制开发者在进行类型转换时必须显式地表明意图，从而使代码更清晰。
减少错误：禁止隐式转换可以避免一些因自动类型转换带来的隐患，尤其是在参数较多、逻辑复杂的场景中。
接口设计：当一个构造函数或转换运算符存在多种可能性时，explicit 能使接口设计更加明确，防止误用。




## 8. C++中的虚表存放在哪？虚表中保存了什么？
### 8.1 虚表(vtable)的内存区域
虚表由编译阶段静态生成，通常存放程序的只读数据段(.rodata)或全局/静态数据段(.data)中：
* 只读数据段(.rodata)： 若编译器将虚表视为常量(例如GCC)，虚表会被标记为只读，防止程序意外修改。
* 全局/静态数据段(.data)： 某些编译器可能将虚表存放在可读的数据段中, 但虚表内容在程序运行期间一般不会变化
虚表本身是类级别的数据据结构，同一类的所有对象共享一份虚表

### 8.2 虚表保存的内容
虚表本质上是一个函数指针数组，每个条目指向类中虚函数的具体实现。其内容主要包括：
1. 虚函数的地址
* 按声明顺序存储类中所有虚函数的地址(包括继承的虚函数)
* 若派生类覆盖了基类的虚函数，则虚表中对应条目替换为派生类函数的地址
* 若虚函数未被覆盖，则指向基类的实现。

2. RTTI（运行时类型信息）指针
* 虚表通常关联一个type_info对象，用于支持dynamic_cast和typeid操作。
* 该指针可能位于虚表的开头或结尾，具体位置因编译器而异

- 代码示例
```cpp
class Base{
public:
    virtual void func1(){}
    virtual void func2(){}
};

class Derived: public Base{
public:
    void func1 override {}  // 覆盖基类的fun1
}

```
* Base的虚表：
【0】Base::func1()的地址
【1】Base::func2()的地址
【可能附加type_info】
* Derived的虚表
【0】Deried::func1()        // 覆盖基类func1
【1】Base::func2()          // 未覆盖，沿用基类
【可能附加【type_info】


### 8.3 对象内存布局与虚指针(vptr)
每个包含虚函数的对象实例会在内存头部(通常是最开始的位置)保存一个指向虚表的指针vptr
**vptr的初始化**: 在对象构造时，由构造函数隐式设置其指向正确的虚表 
- 对象的内存布局
```cpp
class A{
public:
    virtual void foo(){}
    int x;
};
A obj;
```
内存布局（假设 vptr 占用 8 字节，int 占用 4 字节）：

+----------------+     +-------------------+
| vptr (8 bytes) | --> | A 的虚表地址       |
+----------------+     +-------------------+
| x (4 bytes)    |     | A::foo() 的地址   |
+----------------+     +-------------------+


### 8.4 编译器差异
* GCC/Clang: 虚表通常存放在.rodata段(只读)，避免被修改
* MSVC：虚表可能存放在.rodata段(只读)，行为类似；
* 虚表条目顺序：可能因编译器优化或继承顺序不能而变化。但对开发者

### 8.5 总结



## 9. 用unique_ptr作为返回值可以吗？
答案：使用std::unique_ptr作为函数的返回值不仅是合法的，而且是一种推荐做法，尤其在需要明确转移对象所有权时。
https://mp.weixin.qq.com/s/bPCrSuLJe1-42IilcjAthg




## 10. mutable关键字的作用是什么？应用场景有哪些?
### 10.1 基本概念
在C++中，mutable关键字允许在**const成员函数中修改被标记的成员变量**，同时**保持对象的逻辑不变性**。\
核心含义：\
* 用途：修饰类的非静态成员函数
* 核心作用：允许const成员函数中修改该变量的值
* 核心逻辑：
    const成员函数承诺不修改对象的"逻辑状态"，但是mutable允许修改某些"物理状态"(如缓存、调试计数器等)，这些修改不影响对象的对外表现

### 10.2 作用域与限制
1. 仅限类的非静态成员变量
    mutable不能用于：
* 静态成员变量(static 成员属于类，与对象的const性无关)
* 局部变量或全局变量

2. 可搭配其他修饰符
```cpp
mutable volatile int cache; // 用于多线程环境
```
3. 不影响对象的拷贝/移动



## 11. std::scoped_lock是什么？相比于其他的锁管理类有什么区别？为什么要引入这个模板类？
在 C++ 多线程编程中，std::scoped_lock 是一个用于​自动管理多个互斥量(Mutex)的 RAII(资源获取即初始化)工具。它是 C++17 引入的特性，旨在简化**多互斥量的锁定和解锁**操作，同时避免死锁。
使用 std::scoped_lock 可以同时锁定多个互斥量，且内部通过 std::lock 实现 ​死锁避免算法​（如“顺序锁定”或“试探性回退”）。
避免手动锁定多个互斥量时可能出现的顺序不一致问题。

应用场景:
std::scoped_lock 是 C++ 多线程编程中管理多个互斥量的首选工具，它通过 RAII 机制和死锁避免算法，显著简化了代码复杂度并提高了安全性。在以下场景中应优先使用它：
* 需要同时锁定多个互斥量。
* 希望避免手动调用 lock() 和 unlock()。
* 需要确保异常安全。



